// Code generated by protoc-gen-go. DO NOT EDIT.
// source: mysqlx_crud.proto

package mysqlx_crud

/*
Basic CRUD operations
*/

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/renthraysk/mysqlx/protobuf/mysqlx"
import mysqlx_datatypes "github.com/renthraysk/mysqlx/protobuf/mysqlx_datatypes"
import mysqlx_expr "github.com/renthraysk/mysqlx/protobuf/mysqlx_expr"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// DataModel to use for filters, names, ...
type DataModel int32

const (
	DataModel_DOCUMENT DataModel = 1
	DataModel_TABLE    DataModel = 2
)

var DataModel_name = map[int32]string{
	1: "DOCUMENT",
	2: "TABLE",
}
var DataModel_value = map[string]int32{
	"DOCUMENT": 1,
	"TABLE":    2,
}

func (x DataModel) Enum() *DataModel {
	p := new(DataModel)
	*p = x
	return p
}
func (x DataModel) String() string {
	return proto.EnumName(DataModel_name, int32(x))
}
func (x *DataModel) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(DataModel_value, data, "DataModel")
	if err != nil {
		return err
	}
	*x = DataModel(value)
	return nil
}
func (DataModel) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_mysqlx_crud_c88ec9504f16a02d, []int{0}
}

// ViewAlgorithm defines how MySQL Server processes the view
type ViewAlgorithm int32

const (
	ViewAlgorithm_UNDEFINED ViewAlgorithm = 1
	ViewAlgorithm_MERGE     ViewAlgorithm = 2
	ViewAlgorithm_TEMPTABLE ViewAlgorithm = 3
)

var ViewAlgorithm_name = map[int32]string{
	1: "UNDEFINED",
	2: "MERGE",
	3: "TEMPTABLE",
}
var ViewAlgorithm_value = map[string]int32{
	"UNDEFINED": 1,
	"MERGE":     2,
	"TEMPTABLE": 3,
}

func (x ViewAlgorithm) Enum() *ViewAlgorithm {
	p := new(ViewAlgorithm)
	*p = x
	return p
}
func (x ViewAlgorithm) String() string {
	return proto.EnumName(ViewAlgorithm_name, int32(x))
}
func (x *ViewAlgorithm) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ViewAlgorithm_value, data, "ViewAlgorithm")
	if err != nil {
		return err
	}
	*x = ViewAlgorithm(value)
	return nil
}
func (ViewAlgorithm) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_mysqlx_crud_c88ec9504f16a02d, []int{1}
}

// ViewSqlSecurity defines the security context in which the view is going to be
// executed, this means that VIEW can be executed with current user permissions or
// with permissions of the uses who defined the VIEW
type ViewSqlSecurity int32

const (
	ViewSqlSecurity_INVOKER ViewSqlSecurity = 1
	ViewSqlSecurity_DEFINER ViewSqlSecurity = 2
)

var ViewSqlSecurity_name = map[int32]string{
	1: "INVOKER",
	2: "DEFINER",
}
var ViewSqlSecurity_value = map[string]int32{
	"INVOKER": 1,
	"DEFINER": 2,
}

func (x ViewSqlSecurity) Enum() *ViewSqlSecurity {
	p := new(ViewSqlSecurity)
	*p = x
	return p
}
func (x ViewSqlSecurity) String() string {
	return proto.EnumName(ViewSqlSecurity_name, int32(x))
}
func (x *ViewSqlSecurity) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ViewSqlSecurity_value, data, "ViewSqlSecurity")
	if err != nil {
		return err
	}
	*x = ViewSqlSecurity(value)
	return nil
}
func (ViewSqlSecurity) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_mysqlx_crud_c88ec9504f16a02d, []int{2}
}

// ViewCheckOption limits the write operations done on a `VIEW`
// (`INSERT`, `UPDATE`, `DELETE`) to rows in which the `WHERE` clause is `TRUE`
type ViewCheckOption int32

const (
	ViewCheckOption_LOCAL    ViewCheckOption = 1
	ViewCheckOption_CASCADED ViewCheckOption = 2
)

var ViewCheckOption_name = map[int32]string{
	1: "LOCAL",
	2: "CASCADED",
}
var ViewCheckOption_value = map[string]int32{
	"LOCAL":    1,
	"CASCADED": 2,
}

func (x ViewCheckOption) Enum() *ViewCheckOption {
	p := new(ViewCheckOption)
	*p = x
	return p
}
func (x ViewCheckOption) String() string {
	return proto.EnumName(ViewCheckOption_name, int32(x))
}
func (x *ViewCheckOption) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ViewCheckOption_value, data, "ViewCheckOption")
	if err != nil {
		return err
	}
	*x = ViewCheckOption(value)
	return nil
}
func (ViewCheckOption) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_mysqlx_crud_c88ec9504f16a02d, []int{3}
}

type Order_Direction int32

const (
	Order_ASC  Order_Direction = 1
	Order_DESC Order_Direction = 2
)

var Order_Direction_name = map[int32]string{
	1: "ASC",
	2: "DESC",
}
var Order_Direction_value = map[string]int32{
	"ASC":  1,
	"DESC": 2,
}

func (x Order_Direction) Enum() *Order_Direction {
	p := new(Order_Direction)
	*p = x
	return p
}
func (x Order_Direction) String() string {
	return proto.EnumName(Order_Direction_name, int32(x))
}
func (x *Order_Direction) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Order_Direction_value, data, "Order_Direction")
	if err != nil {
		return err
	}
	*x = Order_Direction(value)
	return nil
}
func (Order_Direction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_mysqlx_crud_c88ec9504f16a02d, []int{5, 0}
}

type UpdateOperation_UpdateType int32

const (
	UpdateOperation_SET          UpdateOperation_UpdateType = 1
	UpdateOperation_ITEM_REMOVE  UpdateOperation_UpdateType = 2
	UpdateOperation_ITEM_SET     UpdateOperation_UpdateType = 3
	UpdateOperation_ITEM_REPLACE UpdateOperation_UpdateType = 4
	UpdateOperation_ITEM_MERGE   UpdateOperation_UpdateType = 5
	UpdateOperation_ARRAY_INSERT UpdateOperation_UpdateType = 6
	UpdateOperation_ARRAY_APPEND UpdateOperation_UpdateType = 7
	UpdateOperation_MERGE_PATCH  UpdateOperation_UpdateType = 8
)

var UpdateOperation_UpdateType_name = map[int32]string{
	1: "SET",
	2: "ITEM_REMOVE",
	3: "ITEM_SET",
	4: "ITEM_REPLACE",
	5: "ITEM_MERGE",
	6: "ARRAY_INSERT",
	7: "ARRAY_APPEND",
	8: "MERGE_PATCH",
}
var UpdateOperation_UpdateType_value = map[string]int32{
	"SET":          1,
	"ITEM_REMOVE":  2,
	"ITEM_SET":     3,
	"ITEM_REPLACE": 4,
	"ITEM_MERGE":   5,
	"ARRAY_INSERT": 6,
	"ARRAY_APPEND": 7,
	"MERGE_PATCH":  8,
}

func (x UpdateOperation_UpdateType) Enum() *UpdateOperation_UpdateType {
	p := new(UpdateOperation_UpdateType)
	*p = x
	return p
}
func (x UpdateOperation_UpdateType) String() string {
	return proto.EnumName(UpdateOperation_UpdateType_name, int32(x))
}
func (x *UpdateOperation_UpdateType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(UpdateOperation_UpdateType_value, data, "UpdateOperation_UpdateType")
	if err != nil {
		return err
	}
	*x = UpdateOperation_UpdateType(value)
	return nil
}
func (UpdateOperation_UpdateType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_mysqlx_crud_c88ec9504f16a02d, []int{6, 0}
}

type Find_RowLock int32

const (
	Find_SHARED_LOCK    Find_RowLock = 1
	Find_EXCLUSIVE_LOCK Find_RowLock = 2
)

var Find_RowLock_name = map[int32]string{
	1: "SHARED_LOCK",
	2: "EXCLUSIVE_LOCK",
}
var Find_RowLock_value = map[string]int32{
	"SHARED_LOCK":    1,
	"EXCLUSIVE_LOCK": 2,
}

func (x Find_RowLock) Enum() *Find_RowLock {
	p := new(Find_RowLock)
	*p = x
	return p
}
func (x Find_RowLock) String() string {
	return proto.EnumName(Find_RowLock_name, int32(x))
}
func (x *Find_RowLock) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Find_RowLock_value, data, "Find_RowLock")
	if err != nil {
		return err
	}
	*x = Find_RowLock(value)
	return nil
}
func (Find_RowLock) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_mysqlx_crud_c88ec9504f16a02d, []int{7, 0}
}

type Find_RowLockOptions int32

const (
	Find_NOWAIT      Find_RowLockOptions = 1
	Find_SKIP_LOCKED Find_RowLockOptions = 2
)

var Find_RowLockOptions_name = map[int32]string{
	1: "NOWAIT",
	2: "SKIP_LOCKED",
}
var Find_RowLockOptions_value = map[string]int32{
	"NOWAIT":      1,
	"SKIP_LOCKED": 2,
}

func (x Find_RowLockOptions) Enum() *Find_RowLockOptions {
	p := new(Find_RowLockOptions)
	*p = x
	return p
}
func (x Find_RowLockOptions) String() string {
	return proto.EnumName(Find_RowLockOptions_name, int32(x))
}
func (x *Find_RowLockOptions) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Find_RowLockOptions_value, data, "Find_RowLockOptions")
	if err != nil {
		return err
	}
	*x = Find_RowLockOptions(value)
	return nil
}
func (Find_RowLockOptions) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_mysqlx_crud_c88ec9504f16a02d, []int{7, 1}
}

// column definition
type Column struct {
	Name                 *string                         `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Alias                *string                         `protobuf:"bytes,2,opt,name=alias" json:"alias,omitempty"`
	DocumentPath         []*mysqlx_expr.DocumentPathItem `protobuf:"bytes,3,rep,name=document_path,json=documentPath" json:"document_path,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                        `json:"-"`
	XXX_unrecognized     []byte                          `json:"-"`
	XXX_sizecache        int32                           `json:"-"`
}

func (m *Column) Reset()         { *m = Column{} }
func (m *Column) String() string { return proto.CompactTextString(m) }
func (*Column) ProtoMessage()    {}
func (*Column) Descriptor() ([]byte, []int) {
	return fileDescriptor_mysqlx_crud_c88ec9504f16a02d, []int{0}
}
func (m *Column) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Column.Unmarshal(m, b)
}
func (m *Column) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Column.Marshal(b, m, deterministic)
}
func (dst *Column) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Column.Merge(dst, src)
}
func (m *Column) XXX_Size() int {
	return xxx_messageInfo_Column.Size(m)
}
func (m *Column) XXX_DiscardUnknown() {
	xxx_messageInfo_Column.DiscardUnknown(m)
}

var xxx_messageInfo_Column proto.InternalMessageInfo

func (m *Column) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Column) GetAlias() string {
	if m != nil && m.Alias != nil {
		return *m.Alias
	}
	return ""
}

func (m *Column) GetDocumentPath() []*mysqlx_expr.DocumentPathItem {
	if m != nil {
		return m.DocumentPath
	}
	return nil
}

// a projection
//
// :param source: the expression identifying an element from the source data
//                which can include a column identifier or any expression
// :param alias: optional alias. Required for DOCUMENTs (clients may use
//              the source string as default)
type Projection struct {
	Source               *mysqlx_expr.Expr `protobuf:"bytes,1,req,name=source" json:"source,omitempty"`
	Alias                *string           `protobuf:"bytes,2,opt,name=alias" json:"alias,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Projection) Reset()         { *m = Projection{} }
func (m *Projection) String() string { return proto.CompactTextString(m) }
func (*Projection) ProtoMessage()    {}
func (*Projection) Descriptor() ([]byte, []int) {
	return fileDescriptor_mysqlx_crud_c88ec9504f16a02d, []int{1}
}
func (m *Projection) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Projection.Unmarshal(m, b)
}
func (m *Projection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Projection.Marshal(b, m, deterministic)
}
func (dst *Projection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Projection.Merge(dst, src)
}
func (m *Projection) XXX_Size() int {
	return xxx_messageInfo_Projection.Size(m)
}
func (m *Projection) XXX_DiscardUnknown() {
	xxx_messageInfo_Projection.DiscardUnknown(m)
}

var xxx_messageInfo_Projection proto.InternalMessageInfo

func (m *Projection) GetSource() *mysqlx_expr.Expr {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *Projection) GetAlias() string {
	if m != nil && m.Alias != nil {
		return *m.Alias
	}
	return ""
}

// collection
type Collection struct {
	Name                 *string  `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	Schema               *string  `protobuf:"bytes,2,opt,name=schema" json:"schema,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Collection) Reset()         { *m = Collection{} }
func (m *Collection) String() string { return proto.CompactTextString(m) }
func (*Collection) ProtoMessage()    {}
func (*Collection) Descriptor() ([]byte, []int) {
	return fileDescriptor_mysqlx_crud_c88ec9504f16a02d, []int{2}
}
func (m *Collection) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Collection.Unmarshal(m, b)
}
func (m *Collection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Collection.Marshal(b, m, deterministic)
}
func (dst *Collection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Collection.Merge(dst, src)
}
func (m *Collection) XXX_Size() int {
	return xxx_messageInfo_Collection.Size(m)
}
func (m *Collection) XXX_DiscardUnknown() {
	xxx_messageInfo_Collection.DiscardUnknown(m)
}

var xxx_messageInfo_Collection proto.InternalMessageInfo

func (m *Collection) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Collection) GetSchema() string {
	if m != nil && m.Schema != nil {
		return *m.Schema
	}
	return ""
}

// limit
//
// :param row_count: maximum rows to filter
// :param offset: maximum rows to skip before applying the row_count
type Limit struct {
	RowCount             *uint64  `protobuf:"varint,1,req,name=row_count,json=rowCount" json:"row_count,omitempty"`
	Offset               *uint64  `protobuf:"varint,2,opt,name=offset" json:"offset,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Limit) Reset()         { *m = Limit{} }
func (m *Limit) String() string { return proto.CompactTextString(m) }
func (*Limit) ProtoMessage()    {}
func (*Limit) Descriptor() ([]byte, []int) {
	return fileDescriptor_mysqlx_crud_c88ec9504f16a02d, []int{3}
}
func (m *Limit) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Limit.Unmarshal(m, b)
}
func (m *Limit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Limit.Marshal(b, m, deterministic)
}
func (dst *Limit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Limit.Merge(dst, src)
}
func (m *Limit) XXX_Size() int {
	return xxx_messageInfo_Limit.Size(m)
}
func (m *Limit) XXX_DiscardUnknown() {
	xxx_messageInfo_Limit.DiscardUnknown(m)
}

var xxx_messageInfo_Limit proto.InternalMessageInfo

func (m *Limit) GetRowCount() uint64 {
	if m != nil && m.RowCount != nil {
		return *m.RowCount
	}
	return 0
}

func (m *Limit) GetOffset() uint64 {
	if m != nil && m.Offset != nil {
		return *m.Offset
	}
	return 0
}

// limit expression
//
// LimitExpr in comparison to Limit, is able to specify that row_count and
// offset are placeholders.
// This message support expressions of following types Expr/literal/UINT,
// Expr/PLACEHOLDER.
//
// :param row_count: maximum rows to filter
// :param offset: maximum rows to skip before applying the row_count
type LimitExpr struct {
	RowCount             *mysqlx_expr.Expr `protobuf:"bytes,1,req,name=row_count,json=rowCount" json:"row_count,omitempty"`
	Offset               *mysqlx_expr.Expr `protobuf:"bytes,2,opt,name=offset" json:"offset,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *LimitExpr) Reset()         { *m = LimitExpr{} }
func (m *LimitExpr) String() string { return proto.CompactTextString(m) }
func (*LimitExpr) ProtoMessage()    {}
func (*LimitExpr) Descriptor() ([]byte, []int) {
	return fileDescriptor_mysqlx_crud_c88ec9504f16a02d, []int{4}
}
func (m *LimitExpr) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LimitExpr.Unmarshal(m, b)
}
func (m *LimitExpr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LimitExpr.Marshal(b, m, deterministic)
}
func (dst *LimitExpr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LimitExpr.Merge(dst, src)
}
func (m *LimitExpr) XXX_Size() int {
	return xxx_messageInfo_LimitExpr.Size(m)
}
func (m *LimitExpr) XXX_DiscardUnknown() {
	xxx_messageInfo_LimitExpr.DiscardUnknown(m)
}

var xxx_messageInfo_LimitExpr proto.InternalMessageInfo

func (m *LimitExpr) GetRowCount() *mysqlx_expr.Expr {
	if m != nil {
		return m.RowCount
	}
	return nil
}

func (m *LimitExpr) GetOffset() *mysqlx_expr.Expr {
	if m != nil {
		return m.Offset
	}
	return nil
}

// sort order
type Order struct {
	Expr                 *mysqlx_expr.Expr `protobuf:"bytes,1,req,name=expr" json:"expr,omitempty"`
	Direction            *Order_Direction  `protobuf:"varint,2,opt,name=direction,enum=Mysqlx.Crud.Order_Direction,def=1" json:"direction,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Order) Reset()         { *m = Order{} }
func (m *Order) String() string { return proto.CompactTextString(m) }
func (*Order) ProtoMessage()    {}
func (*Order) Descriptor() ([]byte, []int) {
	return fileDescriptor_mysqlx_crud_c88ec9504f16a02d, []int{5}
}
func (m *Order) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Order.Unmarshal(m, b)
}
func (m *Order) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Order.Marshal(b, m, deterministic)
}
func (dst *Order) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Order.Merge(dst, src)
}
func (m *Order) XXX_Size() int {
	return xxx_messageInfo_Order.Size(m)
}
func (m *Order) XXX_DiscardUnknown() {
	xxx_messageInfo_Order.DiscardUnknown(m)
}

var xxx_messageInfo_Order proto.InternalMessageInfo

const Default_Order_Direction Order_Direction = Order_ASC

func (m *Order) GetExpr() *mysqlx_expr.Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *Order) GetDirection() Order_Direction {
	if m != nil && m.Direction != nil {
		return *m.Direction
	}
	return Default_Order_Direction
}

// update operations
//
// :param source: specification of the value to be updated
//      if data_model is TABLE, a column name may be specified and also a document path, if the column has type JSON
//      if data_model is DOCUMENT, only document paths are allowed
//      in both cases, schema and table must be not set
// :param operation: the type of operation to be performed
// :param value: an expression to be computed as the new value for the operation
type UpdateOperation struct {
	Source               *mysqlx_expr.ColumnIdentifier `protobuf:"bytes,1,req,name=source" json:"source,omitempty"`
	Operation            *UpdateOperation_UpdateType   `protobuf:"varint,2,req,name=operation,enum=Mysqlx.Crud.UpdateOperation_UpdateType" json:"operation,omitempty"`
	Value                *mysqlx_expr.Expr             `protobuf:"bytes,3,opt,name=value" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *UpdateOperation) Reset()         { *m = UpdateOperation{} }
func (m *UpdateOperation) String() string { return proto.CompactTextString(m) }
func (*UpdateOperation) ProtoMessage()    {}
func (*UpdateOperation) Descriptor() ([]byte, []int) {
	return fileDescriptor_mysqlx_crud_c88ec9504f16a02d, []int{6}
}
func (m *UpdateOperation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UpdateOperation.Unmarshal(m, b)
}
func (m *UpdateOperation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UpdateOperation.Marshal(b, m, deterministic)
}
func (dst *UpdateOperation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateOperation.Merge(dst, src)
}
func (m *UpdateOperation) XXX_Size() int {
	return xxx_messageInfo_UpdateOperation.Size(m)
}
func (m *UpdateOperation) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateOperation.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateOperation proto.InternalMessageInfo

func (m *UpdateOperation) GetSource() *mysqlx_expr.ColumnIdentifier {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *UpdateOperation) GetOperation() UpdateOperation_UpdateType {
	if m != nil && m.Operation != nil {
		return *m.Operation
	}
	return UpdateOperation_SET
}

func (m *UpdateOperation) GetValue() *mysqlx_expr.Expr {
	if m != nil {
		return m.Value
	}
	return nil
}

// Find Documents/Rows in a Collection/Table
//
// .. uml::
//
//   client -> server: Find
//   ... one or more Resultset ...
//
// :param collection: collection to insert into
// :param data_model: datamodel that the operations refer to
// :param projection: list of column projections that shall be returned
// :param args: values for parameters used in filter expression
// :param criteria: filter criteria
// :param limit: numbers of rows that shall be skipped and returned (user can set one of: limit, limit_expr)
// :param order: sort-order in which the rows/document shall be returned in
// :param grouping: column expression list for aggregation (GROUP BY)
// :param grouping_criteria: filter criteria for aggregated groups
// :param locking: perform row locking on matches
// :param locking_options: additional options how to handle locked rows
// :param limit_expr: numbers of rows that shall be skipped and returned (user can set one of: limit, limit_expr)
// :Returns: :protobuf:msg:`Mysqlx.Resultset::`
type Find struct {
	Collection           *Collection                `protobuf:"bytes,2,req,name=collection" json:"collection,omitempty"`
	DataModel            *DataModel                 `protobuf:"varint,3,opt,name=data_model,json=dataModel,enum=Mysqlx.Crud.DataModel" json:"data_model,omitempty"`
	Projection           []*Projection              `protobuf:"bytes,4,rep,name=projection" json:"projection,omitempty"`
	Criteria             *mysqlx_expr.Expr          `protobuf:"bytes,5,opt,name=criteria" json:"criteria,omitempty"`
	Args                 []*mysqlx_datatypes.Scalar `protobuf:"bytes,11,rep,name=args" json:"args,omitempty"`
	Order                []*Order                   `protobuf:"bytes,7,rep,name=order" json:"order,omitempty"`
	Grouping             []*mysqlx_expr.Expr        `protobuf:"bytes,8,rep,name=grouping" json:"grouping,omitempty"`
	GroupingCriteria     *mysqlx_expr.Expr          `protobuf:"bytes,9,opt,name=grouping_criteria,json=groupingCriteria" json:"grouping_criteria,omitempty"`
	Locking              *Find_RowLock              `protobuf:"varint,12,opt,name=locking,enum=Mysqlx.Crud.Find_RowLock" json:"locking,omitempty"`
	LockingOptions       *Find_RowLockOptions       `protobuf:"varint,13,opt,name=locking_options,json=lockingOptions,enum=Mysqlx.Crud.Find_RowLockOptions" json:"locking_options,omitempty"`
	Limit                *Limit                     `protobuf:"bytes,6,opt,name=limit" json:"limit,omitempty"`
	LimitExpr            *LimitExpr                 `protobuf:"bytes,14,opt,name=limit_expr,json=limitExpr" json:"limit_expr,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *Find) Reset()         { *m = Find{} }
func (m *Find) String() string { return proto.CompactTextString(m) }
func (*Find) ProtoMessage()    {}
func (*Find) Descriptor() ([]byte, []int) {
	return fileDescriptor_mysqlx_crud_c88ec9504f16a02d, []int{7}
}
func (m *Find) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Find.Unmarshal(m, b)
}
func (m *Find) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Find.Marshal(b, m, deterministic)
}
func (dst *Find) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Find.Merge(dst, src)
}
func (m *Find) XXX_Size() int {
	return xxx_messageInfo_Find.Size(m)
}
func (m *Find) XXX_DiscardUnknown() {
	xxx_messageInfo_Find.DiscardUnknown(m)
}

var xxx_messageInfo_Find proto.InternalMessageInfo

func (m *Find) GetCollection() *Collection {
	if m != nil {
		return m.Collection
	}
	return nil
}

func (m *Find) GetDataModel() DataModel {
	if m != nil && m.DataModel != nil {
		return *m.DataModel
	}
	return DataModel_DOCUMENT
}

func (m *Find) GetProjection() []*Projection {
	if m != nil {
		return m.Projection
	}
	return nil
}

func (m *Find) GetCriteria() *mysqlx_expr.Expr {
	if m != nil {
		return m.Criteria
	}
	return nil
}

func (m *Find) GetArgs() []*mysqlx_datatypes.Scalar {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *Find) GetOrder() []*Order {
	if m != nil {
		return m.Order
	}
	return nil
}

func (m *Find) GetGrouping() []*mysqlx_expr.Expr {
	if m != nil {
		return m.Grouping
	}
	return nil
}

func (m *Find) GetGroupingCriteria() *mysqlx_expr.Expr {
	if m != nil {
		return m.GroupingCriteria
	}
	return nil
}

func (m *Find) GetLocking() Find_RowLock {
	if m != nil && m.Locking != nil {
		return *m.Locking
	}
	return Find_SHARED_LOCK
}

func (m *Find) GetLockingOptions() Find_RowLockOptions {
	if m != nil && m.LockingOptions != nil {
		return *m.LockingOptions
	}
	return Find_NOWAIT
}

func (m *Find) GetLimit() *Limit {
	if m != nil {
		return m.Limit
	}
	return nil
}

func (m *Find) GetLimitExpr() *LimitExpr {
	if m != nil {
		return m.LimitExpr
	}
	return nil
}

// Insert documents/rows into a collection/table
//
// :param collection: collection to insert into
// :param data_model: datamodel that the operations refer to
// :param projection: name of the columns to insert data into (empty if data_model is DOCUMENT)
// :param row: set of rows to insert into the collection/table (a single expression with a JSON document literal or an OBJECT expression)
// :param args: values for parameters used in row expressions
// :param upsert: true if this should be treated as an Upsert (that is, update on duplicate key)
// :Returns: :protobuf:msg:`Mysqlx.Resultset::`
type Insert struct {
	Collection           *Collection                `protobuf:"bytes,1,req,name=collection" json:"collection,omitempty"`
	DataModel            *DataModel                 `protobuf:"varint,2,opt,name=data_model,json=dataModel,enum=Mysqlx.Crud.DataModel" json:"data_model,omitempty"`
	Projection           []*Column                  `protobuf:"bytes,3,rep,name=projection" json:"projection,omitempty"`
	Row                  []*Insert_TypedRow         `protobuf:"bytes,4,rep,name=row" json:"row,omitempty"`
	Args                 []*mysqlx_datatypes.Scalar `protobuf:"bytes,5,rep,name=args" json:"args,omitempty"`
	Upsert               *bool                      `protobuf:"varint,6,opt,name=upsert,def=0" json:"upsert,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *Insert) Reset()         { *m = Insert{} }
func (m *Insert) String() string { return proto.CompactTextString(m) }
func (*Insert) ProtoMessage()    {}
func (*Insert) Descriptor() ([]byte, []int) {
	return fileDescriptor_mysqlx_crud_c88ec9504f16a02d, []int{8}
}
func (m *Insert) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Insert.Unmarshal(m, b)
}
func (m *Insert) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Insert.Marshal(b, m, deterministic)
}
func (dst *Insert) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Insert.Merge(dst, src)
}
func (m *Insert) XXX_Size() int {
	return xxx_messageInfo_Insert.Size(m)
}
func (m *Insert) XXX_DiscardUnknown() {
	xxx_messageInfo_Insert.DiscardUnknown(m)
}

var xxx_messageInfo_Insert proto.InternalMessageInfo

const Default_Insert_Upsert bool = false

func (m *Insert) GetCollection() *Collection {
	if m != nil {
		return m.Collection
	}
	return nil
}

func (m *Insert) GetDataModel() DataModel {
	if m != nil && m.DataModel != nil {
		return *m.DataModel
	}
	return DataModel_DOCUMENT
}

func (m *Insert) GetProjection() []*Column {
	if m != nil {
		return m.Projection
	}
	return nil
}

func (m *Insert) GetRow() []*Insert_TypedRow {
	if m != nil {
		return m.Row
	}
	return nil
}

func (m *Insert) GetArgs() []*mysqlx_datatypes.Scalar {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *Insert) GetUpsert() bool {
	if m != nil && m.Upsert != nil {
		return *m.Upsert
	}
	return Default_Insert_Upsert
}

type Insert_TypedRow struct {
	Field                []*mysqlx_expr.Expr `protobuf:"bytes,1,rep,name=field" json:"field,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *Insert_TypedRow) Reset()         { *m = Insert_TypedRow{} }
func (m *Insert_TypedRow) String() string { return proto.CompactTextString(m) }
func (*Insert_TypedRow) ProtoMessage()    {}
func (*Insert_TypedRow) Descriptor() ([]byte, []int) {
	return fileDescriptor_mysqlx_crud_c88ec9504f16a02d, []int{8, 0}
}
func (m *Insert_TypedRow) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Insert_TypedRow.Unmarshal(m, b)
}
func (m *Insert_TypedRow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Insert_TypedRow.Marshal(b, m, deterministic)
}
func (dst *Insert_TypedRow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Insert_TypedRow.Merge(dst, src)
}
func (m *Insert_TypedRow) XXX_Size() int {
	return xxx_messageInfo_Insert_TypedRow.Size(m)
}
func (m *Insert_TypedRow) XXX_DiscardUnknown() {
	xxx_messageInfo_Insert_TypedRow.DiscardUnknown(m)
}

var xxx_messageInfo_Insert_TypedRow proto.InternalMessageInfo

func (m *Insert_TypedRow) GetField() []*mysqlx_expr.Expr {
	if m != nil {
		return m.Field
	}
	return nil
}

// Update documents/rows in a collection/table
//
// :param collection: collection to change
// :param data_model: datamodel that the operations refer to
// :param criteria: filter expression to match rows that the operations will apply on
// :param args: values for parameters used in filter expression
// :param limit: limits the number of rows to match (user can set one of: limit, limit_expr)
// :param order: specifies order of matched rows
// :param operation: list of operations to be applied. Valid operations will depend on the data_model.
// :param limit_expr: limits the number of rows to match (user can set one of: limit, limit_expr)
// :Returns: :protobuf:msg:`Mysqlx.Resultset::`
type Update struct {
	Collection           *Collection                `protobuf:"bytes,2,req,name=collection" json:"collection,omitempty"`
	DataModel            *DataModel                 `protobuf:"varint,3,opt,name=data_model,json=dataModel,enum=Mysqlx.Crud.DataModel" json:"data_model,omitempty"`
	Criteria             *mysqlx_expr.Expr          `protobuf:"bytes,4,opt,name=criteria" json:"criteria,omitempty"`
	Args                 []*mysqlx_datatypes.Scalar `protobuf:"bytes,8,rep,name=args" json:"args,omitempty"`
	Order                []*Order                   `protobuf:"bytes,6,rep,name=order" json:"order,omitempty"`
	Operation            []*UpdateOperation         `protobuf:"bytes,7,rep,name=operation" json:"operation,omitempty"`
	Limit                *Limit                     `protobuf:"bytes,5,opt,name=limit" json:"limit,omitempty"`
	LimitExpr            *LimitExpr                 `protobuf:"bytes,9,opt,name=limit_expr,json=limitExpr" json:"limit_expr,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *Update) Reset()         { *m = Update{} }
func (m *Update) String() string { return proto.CompactTextString(m) }
func (*Update) ProtoMessage()    {}
func (*Update) Descriptor() ([]byte, []int) {
	return fileDescriptor_mysqlx_crud_c88ec9504f16a02d, []int{9}
}
func (m *Update) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Update.Unmarshal(m, b)
}
func (m *Update) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Update.Marshal(b, m, deterministic)
}
func (dst *Update) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Update.Merge(dst, src)
}
func (m *Update) XXX_Size() int {
	return xxx_messageInfo_Update.Size(m)
}
func (m *Update) XXX_DiscardUnknown() {
	xxx_messageInfo_Update.DiscardUnknown(m)
}

var xxx_messageInfo_Update proto.InternalMessageInfo

func (m *Update) GetCollection() *Collection {
	if m != nil {
		return m.Collection
	}
	return nil
}

func (m *Update) GetDataModel() DataModel {
	if m != nil && m.DataModel != nil {
		return *m.DataModel
	}
	return DataModel_DOCUMENT
}

func (m *Update) GetCriteria() *mysqlx_expr.Expr {
	if m != nil {
		return m.Criteria
	}
	return nil
}

func (m *Update) GetArgs() []*mysqlx_datatypes.Scalar {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *Update) GetOrder() []*Order {
	if m != nil {
		return m.Order
	}
	return nil
}

func (m *Update) GetOperation() []*UpdateOperation {
	if m != nil {
		return m.Operation
	}
	return nil
}

func (m *Update) GetLimit() *Limit {
	if m != nil {
		return m.Limit
	}
	return nil
}

func (m *Update) GetLimitExpr() *LimitExpr {
	if m != nil {
		return m.LimitExpr
	}
	return nil
}

// Delete documents/rows from a Collection/Table
//
// :param collection: collection to change
// :param data_model: datamodel that the operations refer to
// :param criteria: filter expression to match rows that the operations will apply on
// :param args: values for parameters used in filter expression
// :param limit: limits the number of rows to match (user can set one of: limit, limit_expr)
// :param order: specifies order of matched rows
// :param limit_expr: limits the number of rows to match (user can set one of: limit, limit_expr)
// :Returns: :protobuf:msg:`Mysqlx.Resultset::`
type Delete struct {
	Collection           *Collection                `protobuf:"bytes,1,req,name=collection" json:"collection,omitempty"`
	DataModel            *DataModel                 `protobuf:"varint,2,opt,name=data_model,json=dataModel,enum=Mysqlx.Crud.DataModel" json:"data_model,omitempty"`
	Criteria             *mysqlx_expr.Expr          `protobuf:"bytes,3,opt,name=criteria" json:"criteria,omitempty"`
	Args                 []*mysqlx_datatypes.Scalar `protobuf:"bytes,6,rep,name=args" json:"args,omitempty"`
	Order                []*Order                   `protobuf:"bytes,5,rep,name=order" json:"order,omitempty"`
	Limit                *Limit                     `protobuf:"bytes,4,opt,name=limit" json:"limit,omitempty"`
	LimitExpr            *LimitExpr                 `protobuf:"bytes,7,opt,name=limit_expr,json=limitExpr" json:"limit_expr,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *Delete) Reset()         { *m = Delete{} }
func (m *Delete) String() string { return proto.CompactTextString(m) }
func (*Delete) ProtoMessage()    {}
func (*Delete) Descriptor() ([]byte, []int) {
	return fileDescriptor_mysqlx_crud_c88ec9504f16a02d, []int{10}
}
func (m *Delete) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Delete.Unmarshal(m, b)
}
func (m *Delete) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Delete.Marshal(b, m, deterministic)
}
func (dst *Delete) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Delete.Merge(dst, src)
}
func (m *Delete) XXX_Size() int {
	return xxx_messageInfo_Delete.Size(m)
}
func (m *Delete) XXX_DiscardUnknown() {
	xxx_messageInfo_Delete.DiscardUnknown(m)
}

var xxx_messageInfo_Delete proto.InternalMessageInfo

func (m *Delete) GetCollection() *Collection {
	if m != nil {
		return m.Collection
	}
	return nil
}

func (m *Delete) GetDataModel() DataModel {
	if m != nil && m.DataModel != nil {
		return *m.DataModel
	}
	return DataModel_DOCUMENT
}

func (m *Delete) GetCriteria() *mysqlx_expr.Expr {
	if m != nil {
		return m.Criteria
	}
	return nil
}

func (m *Delete) GetArgs() []*mysqlx_datatypes.Scalar {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *Delete) GetOrder() []*Order {
	if m != nil {
		return m.Order
	}
	return nil
}

func (m *Delete) GetLimit() *Limit {
	if m != nil {
		return m.Limit
	}
	return nil
}

func (m *Delete) GetLimitExpr() *LimitExpr {
	if m != nil {
		return m.LimitExpr
	}
	return nil
}

type CreateView struct {
	Collection           *Collection      `protobuf:"bytes,1,req,name=collection" json:"collection,omitempty"`
	Definer              *string          `protobuf:"bytes,2,opt,name=definer" json:"definer,omitempty"`
	Algorithm            *ViewAlgorithm   `protobuf:"varint,3,opt,name=algorithm,enum=Mysqlx.Crud.ViewAlgorithm,def=1" json:"algorithm,omitempty"`
	Security             *ViewSqlSecurity `protobuf:"varint,4,opt,name=security,enum=Mysqlx.Crud.ViewSqlSecurity,def=2" json:"security,omitempty"`
	Check                *ViewCheckOption `protobuf:"varint,5,opt,name=check,enum=Mysqlx.Crud.ViewCheckOption" json:"check,omitempty"`
	Column               []string         `protobuf:"bytes,6,rep,name=column" json:"column,omitempty"`
	Stmt                 *Find            `protobuf:"bytes,7,req,name=stmt" json:"stmt,omitempty"`
	ReplaceExisting      *bool            `protobuf:"varint,8,opt,name=replace_existing,json=replaceExisting,def=0" json:"replace_existing,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *CreateView) Reset()         { *m = CreateView{} }
func (m *CreateView) String() string { return proto.CompactTextString(m) }
func (*CreateView) ProtoMessage()    {}
func (*CreateView) Descriptor() ([]byte, []int) {
	return fileDescriptor_mysqlx_crud_c88ec9504f16a02d, []int{11}
}
func (m *CreateView) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CreateView.Unmarshal(m, b)
}
func (m *CreateView) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CreateView.Marshal(b, m, deterministic)
}
func (dst *CreateView) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateView.Merge(dst, src)
}
func (m *CreateView) XXX_Size() int {
	return xxx_messageInfo_CreateView.Size(m)
}
func (m *CreateView) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateView.DiscardUnknown(m)
}

var xxx_messageInfo_CreateView proto.InternalMessageInfo

const Default_CreateView_Algorithm ViewAlgorithm = ViewAlgorithm_UNDEFINED
const Default_CreateView_Security ViewSqlSecurity = ViewSqlSecurity_DEFINER
const Default_CreateView_ReplaceExisting bool = false

func (m *CreateView) GetCollection() *Collection {
	if m != nil {
		return m.Collection
	}
	return nil
}

func (m *CreateView) GetDefiner() string {
	if m != nil && m.Definer != nil {
		return *m.Definer
	}
	return ""
}

func (m *CreateView) GetAlgorithm() ViewAlgorithm {
	if m != nil && m.Algorithm != nil {
		return *m.Algorithm
	}
	return Default_CreateView_Algorithm
}

func (m *CreateView) GetSecurity() ViewSqlSecurity {
	if m != nil && m.Security != nil {
		return *m.Security
	}
	return Default_CreateView_Security
}

func (m *CreateView) GetCheck() ViewCheckOption {
	if m != nil && m.Check != nil {
		return *m.Check
	}
	return ViewCheckOption_LOCAL
}

func (m *CreateView) GetColumn() []string {
	if m != nil {
		return m.Column
	}
	return nil
}

func (m *CreateView) GetStmt() *Find {
	if m != nil {
		return m.Stmt
	}
	return nil
}

func (m *CreateView) GetReplaceExisting() bool {
	if m != nil && m.ReplaceExisting != nil {
		return *m.ReplaceExisting
	}
	return Default_CreateView_ReplaceExisting
}

type ModifyView struct {
	Collection           *Collection      `protobuf:"bytes,1,req,name=collection" json:"collection,omitempty"`
	Definer              *string          `protobuf:"bytes,2,opt,name=definer" json:"definer,omitempty"`
	Algorithm            *ViewAlgorithm   `protobuf:"varint,3,opt,name=algorithm,enum=Mysqlx.Crud.ViewAlgorithm" json:"algorithm,omitempty"`
	Security             *ViewSqlSecurity `protobuf:"varint,4,opt,name=security,enum=Mysqlx.Crud.ViewSqlSecurity" json:"security,omitempty"`
	Check                *ViewCheckOption `protobuf:"varint,5,opt,name=check,enum=Mysqlx.Crud.ViewCheckOption" json:"check,omitempty"`
	Column               []string         `protobuf:"bytes,6,rep,name=column" json:"column,omitempty"`
	Stmt                 *Find            `protobuf:"bytes,7,opt,name=stmt" json:"stmt,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *ModifyView) Reset()         { *m = ModifyView{} }
func (m *ModifyView) String() string { return proto.CompactTextString(m) }
func (*ModifyView) ProtoMessage()    {}
func (*ModifyView) Descriptor() ([]byte, []int) {
	return fileDescriptor_mysqlx_crud_c88ec9504f16a02d, []int{12}
}
func (m *ModifyView) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ModifyView.Unmarshal(m, b)
}
func (m *ModifyView) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ModifyView.Marshal(b, m, deterministic)
}
func (dst *ModifyView) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModifyView.Merge(dst, src)
}
func (m *ModifyView) XXX_Size() int {
	return xxx_messageInfo_ModifyView.Size(m)
}
func (m *ModifyView) XXX_DiscardUnknown() {
	xxx_messageInfo_ModifyView.DiscardUnknown(m)
}

var xxx_messageInfo_ModifyView proto.InternalMessageInfo

func (m *ModifyView) GetCollection() *Collection {
	if m != nil {
		return m.Collection
	}
	return nil
}

func (m *ModifyView) GetDefiner() string {
	if m != nil && m.Definer != nil {
		return *m.Definer
	}
	return ""
}

func (m *ModifyView) GetAlgorithm() ViewAlgorithm {
	if m != nil && m.Algorithm != nil {
		return *m.Algorithm
	}
	return ViewAlgorithm_UNDEFINED
}

func (m *ModifyView) GetSecurity() ViewSqlSecurity {
	if m != nil && m.Security != nil {
		return *m.Security
	}
	return ViewSqlSecurity_INVOKER
}

func (m *ModifyView) GetCheck() ViewCheckOption {
	if m != nil && m.Check != nil {
		return *m.Check
	}
	return ViewCheckOption_LOCAL
}

func (m *ModifyView) GetColumn() []string {
	if m != nil {
		return m.Column
	}
	return nil
}

func (m *ModifyView) GetStmt() *Find {
	if m != nil {
		return m.Stmt
	}
	return nil
}

type DropView struct {
	Collection           *Collection `protobuf:"bytes,1,req,name=collection" json:"collection,omitempty"`
	IfExists             *bool       `protobuf:"varint,2,opt,name=if_exists,json=ifExists,def=0" json:"if_exists,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *DropView) Reset()         { *m = DropView{} }
func (m *DropView) String() string { return proto.CompactTextString(m) }
func (*DropView) ProtoMessage()    {}
func (*DropView) Descriptor() ([]byte, []int) {
	return fileDescriptor_mysqlx_crud_c88ec9504f16a02d, []int{13}
}
func (m *DropView) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DropView.Unmarshal(m, b)
}
func (m *DropView) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DropView.Marshal(b, m, deterministic)
}
func (dst *DropView) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DropView.Merge(dst, src)
}
func (m *DropView) XXX_Size() int {
	return xxx_messageInfo_DropView.Size(m)
}
func (m *DropView) XXX_DiscardUnknown() {
	xxx_messageInfo_DropView.DiscardUnknown(m)
}

var xxx_messageInfo_DropView proto.InternalMessageInfo

const Default_DropView_IfExists bool = false

func (m *DropView) GetCollection() *Collection {
	if m != nil {
		return m.Collection
	}
	return nil
}

func (m *DropView) GetIfExists() bool {
	if m != nil && m.IfExists != nil {
		return *m.IfExists
	}
	return Default_DropView_IfExists
}

func init() {
	proto.RegisterType((*Column)(nil), "Mysqlx.Crud.Column")
	proto.RegisterType((*Projection)(nil), "Mysqlx.Crud.Projection")
	proto.RegisterType((*Collection)(nil), "Mysqlx.Crud.Collection")
	proto.RegisterType((*Limit)(nil), "Mysqlx.Crud.Limit")
	proto.RegisterType((*LimitExpr)(nil), "Mysqlx.Crud.LimitExpr")
	proto.RegisterType((*Order)(nil), "Mysqlx.Crud.Order")
	proto.RegisterType((*UpdateOperation)(nil), "Mysqlx.Crud.UpdateOperation")
	proto.RegisterType((*Find)(nil), "Mysqlx.Crud.Find")
	proto.RegisterType((*Insert)(nil), "Mysqlx.Crud.Insert")
	proto.RegisterType((*Insert_TypedRow)(nil), "Mysqlx.Crud.Insert.TypedRow")
	proto.RegisterType((*Update)(nil), "Mysqlx.Crud.Update")
	proto.RegisterType((*Delete)(nil), "Mysqlx.Crud.Delete")
	proto.RegisterType((*CreateView)(nil), "Mysqlx.Crud.CreateView")
	proto.RegisterType((*ModifyView)(nil), "Mysqlx.Crud.ModifyView")
	proto.RegisterType((*DropView)(nil), "Mysqlx.Crud.DropView")
	proto.RegisterEnum("Mysqlx.Crud.DataModel", DataModel_name, DataModel_value)
	proto.RegisterEnum("Mysqlx.Crud.ViewAlgorithm", ViewAlgorithm_name, ViewAlgorithm_value)
	proto.RegisterEnum("Mysqlx.Crud.ViewSqlSecurity", ViewSqlSecurity_name, ViewSqlSecurity_value)
	proto.RegisterEnum("Mysqlx.Crud.ViewCheckOption", ViewCheckOption_name, ViewCheckOption_value)
	proto.RegisterEnum("Mysqlx.Crud.Order_Direction", Order_Direction_name, Order_Direction_value)
	proto.RegisterEnum("Mysqlx.Crud.UpdateOperation_UpdateType", UpdateOperation_UpdateType_name, UpdateOperation_UpdateType_value)
	proto.RegisterEnum("Mysqlx.Crud.Find_RowLock", Find_RowLock_name, Find_RowLock_value)
	proto.RegisterEnum("Mysqlx.Crud.Find_RowLockOptions", Find_RowLockOptions_name, Find_RowLockOptions_value)
}

func init() { proto.RegisterFile("mysqlx_crud.proto", fileDescriptor_mysqlx_crud_c88ec9504f16a02d) }

var fileDescriptor_mysqlx_crud_c88ec9504f16a02d = []byte{
	// 1351 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x57, 0xdb, 0x6e, 0xdb, 0x46,
	0x13, 0x86, 0x28, 0x51, 0x12, 0x47, 0xb6, 0x4c, 0x6f, 0x02, 0x87, 0xf1, 0xff, 0x27, 0x35, 0x88,
	0x16, 0x71, 0xdc, 0x86, 0x08, 0x14, 0x04, 0x35, 0x8c, 0xa2, 0x05, 0x43, 0x32, 0x8d, 0x10, 0x9d,
	0xb0, 0x92, 0xdd, 0xf6, 0x4a, 0x60, 0xc9, 0x95, 0xcd, 0x84, 0x12, 0x19, 0x92, 0x8a, 0xe3, 0x37,
	0x28, 0xd0, 0x8b, 0x02, 0x7d, 0x84, 0x3e, 0x4c, 0xaf, 0xfa, 0x1a, 0xed, 0x45, 0xfb, 0x12, 0xc5,
	0x2e, 0x97, 0x94, 0xa8, 0xd8, 0x8d, 0x95, 0x22, 0xbd, 0x11, 0xb8, 0x3b, 0xdf, 0x1c, 0x76, 0xbe,
	0x99, 0xd9, 0x15, 0x6c, 0x4f, 0x2f, 0xe2, 0x57, 0xfe, 0x9b, 0xb1, 0x13, 0xcd, 0x5d, 0x2d, 0x8c,
	0x82, 0x24, 0x40, 0x8d, 0x2e, 0xdb, 0xd2, 0x8c, 0x68, 0xee, 0xee, 0x6e, 0xa4, 0xf2, 0x54, 0xb4,
	0x9b, 0xa1, 0xc9, 0x9b, 0x30, 0xe2, 0x5b, 0x3b, 0x7c, 0xcb, 0xb5, 0x13, 0x3b, 0xb9, 0x08, 0x49,
	0x9c, 0xee, 0xab, 0xaf, 0xa1, 0x6a, 0x04, 0xfe, 0x7c, 0x3a, 0x43, 0x08, 0x2a, 0x33, 0x7b, 0x4a,
	0x94, 0xd2, 0x5e, 0x69, 0x5f, 0xc2, 0xec, 0x1b, 0xdd, 0x04, 0xd1, 0xf6, 0x3d, 0x3b, 0x56, 0x04,
	0xb6, 0x99, 0x2e, 0xd0, 0x13, 0xd8, 0x74, 0x03, 0x67, 0x3e, 0x25, 0xb3, 0x64, 0x1c, 0xda, 0xc9,
	0x99, 0x52, 0xde, 0x2b, 0xef, 0x37, 0x5a, 0x77, 0x34, 0x1e, 0x91, 0x45, 0xdd, 0x9a, 0x1c, 0x31,
	0xb0, 0x93, 0xb3, 0x76, 0x42, 0xa6, 0x78, 0xc3, 0x5d, 0xda, 0x51, 0xbb, 0x00, 0x83, 0x28, 0x78,
	0x41, 0x9c, 0xc4, 0x0b, 0x66, 0xe8, 0x3e, 0x54, 0xe3, 0x60, 0x1e, 0x39, 0xd4, 0xbb, 0xb0, 0xdf,
	0x68, 0x6d, 0x17, 0x4c, 0xd1, 0x1f, 0xcc, 0x01, 0x97, 0x87, 0xa4, 0x1e, 0x02, 0x18, 0x81, 0xef,
	0x73, 0x73, 0x8b, 0xa3, 0x08, 0xf9, 0x51, 0x76, 0xa0, 0x1a, 0x3b, 0x67, 0x64, 0x6a, 0x73, 0x45,
	0xbe, 0x52, 0xbf, 0x00, 0xb1, 0xe3, 0x4d, 0xbd, 0x04, 0xfd, 0x0f, 0xa4, 0x28, 0x38, 0x1f, 0x3b,
	0xc1, 0x7c, 0x96, 0x30, 0xcd, 0x0a, 0xae, 0x47, 0xc1, 0xb9, 0x41, 0xd7, 0x54, 0x3b, 0x98, 0x4c,
	0x62, 0x92, 0x30, 0xed, 0x0a, 0xe6, 0x2b, 0x75, 0x02, 0x12, 0xd3, 0xa6, 0x21, 0x22, 0x6d, 0xd5,
	0xc2, 0xa5, 0x07, 0x59, 0x18, 0xbd, 0x5f, 0x30, 0x7a, 0xf9, 0xa9, 0xb9, 0x9f, 0x9f, 0x4a, 0x20,
	0xf6, 0x23, 0x97, 0x44, 0xe8, 0x13, 0xa8, 0x50, 0x5a, 0xaf, 0xb6, 0xcf, 0xc4, 0xe8, 0x2b, 0x90,
	0x5c, 0x2f, 0x4a, 0xf3, 0xc1, 0xcc, 0x37, 0x5b, 0xff, 0xd7, 0x96, 0x2a, 0x46, 0x63, 0xd6, 0x34,
	0x33, 0xc3, 0x1c, 0x95, 0xf5, 0xa1, 0x81, 0x17, 0x3a, 0xea, 0x5d, 0x90, 0x72, 0x21, 0xaa, 0x01,
	0x15, 0xcb, 0x25, 0x54, 0x87, 0x8a, 0x69, 0x0d, 0x0d, 0x59, 0x50, 0x7f, 0x15, 0x60, 0xeb, 0x38,
	0x74, 0xed, 0x84, 0xf4, 0x43, 0x12, 0xd9, 0x0c, 0xf6, 0x78, 0x85, 0xc6, 0x62, 0x45, 0xa4, 0x75,
	0xd6, 0x76, 0xc9, 0x2c, 0xf1, 0x26, 0x1e, 0x59, 0x50, 0x6a, 0x81, 0x14, 0x64, 0x36, 0x14, 0x61,
	0x4f, 0xd8, 0x6f, 0xb6, 0xee, 0x15, 0x62, 0x5d, 0xf1, 0xc3, 0xd7, 0xa3, 0x8b, 0x90, 0xe0, 0x85,
	0x26, 0xba, 0x07, 0xe2, 0x6b, 0xdb, 0x9f, 0x13, 0xa5, 0x7c, 0x55, 0x36, 0x53, 0xb9, 0xfa, 0x63,
	0x09, 0x60, 0x61, 0x82, 0x1e, 0x6e, 0x68, 0x8d, 0xe4, 0x12, 0xda, 0x82, 0x46, 0x7b, 0x64, 0x75,
	0xc7, 0xd8, 0xea, 0xf6, 0x4f, 0x2c, 0x59, 0x40, 0x1b, 0x50, 0x67, 0x1b, 0x54, 0x5c, 0x46, 0x32,
	0x6c, 0x70, 0xf1, 0xa0, 0xa3, 0x1b, 0x96, 0x5c, 0x41, 0x4d, 0x00, 0xb6, 0xd3, 0xb5, 0xf0, 0xd7,
	0x96, 0x2c, 0x52, 0x84, 0x8e, 0xb1, 0xfe, 0xdd, 0xb8, 0xdd, 0x1b, 0x5a, 0x78, 0x24, 0x57, 0x17,
	0x3b, 0xfa, 0x60, 0x60, 0xf5, 0x4c, 0xb9, 0x46, 0x9d, 0x30, 0xf8, 0x78, 0xa0, 0x8f, 0x8c, 0x67,
	0x72, 0x5d, 0xfd, 0x4b, 0x84, 0xca, 0x53, 0x6f, 0xe6, 0xa2, 0xcf, 0x01, 0x9c, 0xbc, 0x86, 0x59,
	0x1e, 0x1a, 0xad, 0x5b, 0x85, 0x3c, 0x2c, 0x4a, 0x1c, 0x2f, 0x41, 0xd1, 0x63, 0x00, 0xda, 0xd6,
	0xe3, 0x69, 0xe0, 0x12, 0x9f, 0x9d, 0xbe, 0xd9, 0xda, 0x29, 0x28, 0x9a, 0x76, 0x62, 0x77, 0xa9,
	0x14, 0x4b, 0x6e, 0xf6, 0x49, 0xfd, 0x85, 0x79, 0x0b, 0x2a, 0x15, 0xd6, 0xc3, 0x45, 0x7f, 0x8b,
	0x0e, 0xc5, 0x4b, 0x50, 0xf4, 0x00, 0xea, 0x4e, 0xe4, 0x25, 0x24, 0xf2, 0x6c, 0x45, 0xbc, 0x2a,
	0xd7, 0x39, 0x04, 0x7d, 0x06, 0x15, 0x3b, 0x3a, 0x8d, 0x95, 0x06, 0xf3, 0xa0, 0x64, 0x50, 0x33,
	0x9f, 0x44, 0x43, 0xc7, 0xf6, 0xed, 0x08, 0x33, 0x14, 0xda, 0x07, 0x31, 0xa0, 0xa5, 0xa9, 0xd4,
	0x18, 0x1c, 0xbd, 0x5d, 0xb4, 0x38, 0x05, 0xd0, 0x30, 0x4e, 0xa3, 0x60, 0x1e, 0x7a, 0xb3, 0x53,
	0xa5, 0xce, 0xc0, 0x97, 0x85, 0x91, 0x41, 0xd0, 0x97, 0xb0, 0x9d, 0x7d, 0x8f, 0xf3, 0xf0, 0xa5,
	0xab, 0xc2, 0x97, 0x33, 0xac, 0x91, 0x1d, 0xe3, 0x11, 0xd4, 0xfc, 0xc0, 0x79, 0x49, 0xbd, 0x6d,
	0xb0, 0x14, 0xdf, 0x2e, 0x84, 0x46, 0x29, 0xd4, 0x70, 0x70, 0xde, 0x09, 0x9c, 0x97, 0x38, 0x43,
	0xa2, 0x36, 0x6c, 0xf1, 0xcf, 0x71, 0x10, 0xd2, 0xe4, 0xc5, 0xca, 0x26, 0x53, 0xde, 0xbb, 0x52,
	0xb9, 0x9f, 0xe2, 0x70, 0x93, 0x2b, 0xf2, 0x35, 0x4d, 0x8c, 0x4f, 0x47, 0x8d, 0x52, 0x65, 0x31,
	0x17, 0x13, 0xc3, 0x86, 0x10, 0x4e, 0x01, 0xb4, 0x1e, 0xd8, 0x07, 0x9b, 0xff, 0x4a, 0x93, 0xc1,
	0x77, 0xde, 0x86, 0xb3, 0x73, 0x4a, 0x7e, 0xf6, 0xa9, 0x6a, 0x50, 0xe3, 0x21, 0xd0, 0x22, 0x1d,
	0x3e, 0xd3, 0xb1, 0x65, 0x8e, 0x3b, 0x7d, 0xe3, 0xb9, 0x5c, 0x42, 0x08, 0x9a, 0xd6, 0xb7, 0x46,
	0xe7, 0x78, 0xd8, 0x3e, 0xb1, 0xd2, 0x3d, 0x41, 0x7d, 0x00, 0xcd, 0x62, 0xc8, 0x08, 0xa0, 0xda,
	0xeb, 0x7f, 0xa3, 0xb7, 0x79, 0x33, 0x0d, 0x9f, 0xb7, 0x07, 0x0c, 0x6c, 0x99, 0xb2, 0x70, 0x54,
	0xf9, 0xe1, 0xcf, 0x87, 0xdb, 0xea, 0xef, 0x02, 0x54, 0xdb, 0xb3, 0x98, 0x44, 0xc9, 0x4a, 0xbd,
	0x97, 0xde, 0xb7, 0xde, 0x85, 0xeb, 0xd6, 0xfb, 0xa3, 0x42, 0xbd, 0xa7, 0x77, 0xd6, 0x8d, 0x55,
	0x7f, 0xf3, 0x69, 0xb1, 0xd6, 0x35, 0x28, 0x47, 0xc1, 0x39, 0xef, 0x8e, 0xe2, 0x04, 0x4d, 0x8f,
	0xa1, 0xd1, 0x19, 0xe2, 0xe2, 0xe0, 0x1c, 0x53, 0x60, 0x5e, 0xec, 0xe2, 0xb5, 0x8a, 0xfd, 0x0e,
	0x54, 0xe7, 0x21, 0xb5, 0xc2, 0x48, 0xad, 0x1f, 0x89, 0x13, 0xdb, 0x8f, 0x09, 0xe6, 0x9b, 0xbb,
	0x8f, 0xa0, 0x9e, 0x59, 0xa7, 0xd3, 0x6d, 0xe2, 0x11, 0xdf, 0x55, 0x4a, 0x57, 0x95, 0x7a, 0x2a,
	0x67, 0x79, 0x46, 0xea, 0x2f, 0x65, 0xa8, 0xa6, 0x33, 0xee, 0x3f, 0x9f, 0x2b, 0xcb, 0xe3, 0xa1,
	0x72, 0xfd, 0xf1, 0x50, 0x5f, 0x6f, 0x3c, 0x54, 0xdf, 0x35, 0x1e, 0x8e, 0x96, 0x6f, 0x95, 0xda,
	0x25, 0xfc, 0xad, 0xdc, 0x2a, 0xcb, 0x57, 0x49, 0xde, 0x6b, 0xe2, 0x7a, 0xbd, 0x26, 0x5d, 0xb3,
	0xd7, 0x18, 0x49, 0x37, 0xd4, 0x3f, 0x04, 0xa8, 0x9a, 0xc4, 0x27, 0x6f, 0x91, 0xf4, 0xe1, 0x9b,
	0x61, 0x99, 0xa4, 0xf2, 0xf5, 0x49, 0xaa, 0xae, 0x47, 0x92, 0xf8, 0x2e, 0x92, 0xf2, 0x44, 0x57,
	0xd6, 0x4b, 0x74, 0x6d, 0x9d, 0x44, 0xdf, 0x54, 0x7f, 0x2e, 0x03, 0x18, 0x11, 0xb1, 0x13, 0x72,
	0xe2, 0x91, 0xf3, 0xf7, 0x4f, 0xb6, 0x02, 0x35, 0x97, 0x4c, 0xbc, 0x19, 0x89, 0xf8, 0x2b, 0x32,
	0x5b, 0x22, 0x03, 0x24, 0xdb, 0x3f, 0x0d, 0x22, 0x2f, 0x39, 0x9b, 0xf2, 0x56, 0xd9, 0x2d, 0x58,
	0xa4, 0x8e, 0xf5, 0x0c, 0x71, 0x24, 0x1d, 0xf7, 0x4c, 0xeb, 0x69, 0xbb, 0x67, 0x99, 0x78, 0xa1,
	0x87, 0x74, 0xa8, 0xc7, 0xc4, 0x99, 0x47, 0x5e, 0x72, 0xc1, 0x12, 0xb2, 0xfa, 0x66, 0xa3, 0x36,
	0x86, 0xaf, 0xfc, 0x21, 0xc7, 0x1c, 0xd5, 0x52, 0x1b, 0x18, 0xe7, 0x6a, 0xa8, 0x05, 0xa2, 0x73,
	0x46, 0x9c, 0x97, 0xac, 0x72, 0x2f, 0xd3, 0x37, 0xa8, 0x34, 0x1d, 0xd8, 0x38, 0x85, 0xd2, 0xc7,
	0xad, 0xc3, 0x26, 0x1f, 0xa3, 0x57, 0xc2, 0x7c, 0x45, 0x9f, 0x9a, 0x71, 0x32, 0x4d, 0x94, 0x5a,
	0xf1, 0xa9, 0x99, 0xdf, 0x58, 0x98, 0x89, 0xd1, 0x43, 0x90, 0x23, 0x12, 0xfa, 0xb6, 0x43, 0xc6,
	0xe4, 0x8d, 0x17, 0x27, 0xe9, 0x7d, 0xbc, 0x34, 0xce, 0xb6, 0xb8, 0xd8, 0xe2, 0x52, 0x46, 0xca,
	0x5d, 0xf5, 0x37, 0x01, 0xa0, 0x1b, 0xb8, 0xde, 0xe4, 0xe2, 0x43, 0x91, 0x72, 0xb8, 0x16, 0x29,
	0xcb, 0x4c, 0x1c, 0xae, 0xc7, 0xc4, 0x07, 0x27, 0xa0, 0xf4, 0x0f, 0x04, 0xb0, 0x74, 0x7e, 0xa4,
	0x4e, 0xa1, 0x6e, 0x46, 0x41, 0xf8, 0xef, 0x72, 0xa9, 0x82, 0xe4, 0x4d, 0x52, 0x1a, 0xd3, 0x7f,
	0x58, 0x39, 0x89, 0x75, 0x6f, 0xc2, 0xf8, 0x8b, 0x99, 0xbb, 0xbd, 0x83, 0x8f, 0x41, 0xca, 0x07,
	0x0b, 0x7d, 0x28, 0x9b, 0x7d, 0xe3, 0xb8, 0x6b, 0xf5, 0xe8, 0xd5, 0x2f, 0x81, 0x38, 0xd2, 0x9f,
	0x74, 0x2c, 0x59, 0x38, 0x38, 0x84, 0xcd, 0x42, 0x8e, 0xd1, 0x26, 0x2c, 0x4a, 0x3f, 0x85, 0xa6,
	0x8f, 0x67, 0x81, 0x4a, 0x46, 0x56, 0x77, 0x90, 0x6a, 0x96, 0x0f, 0x3e, 0x85, 0xad, 0x95, 0x24,
	0xa3, 0x06, 0xd4, 0xda, 0xbd, 0x93, 0xfe, 0x73, 0x0b, 0xcb, 0x25, 0xba, 0xe0, 0xd5, 0x2f, 0x0b,
	0x07, 0x07, 0x29, 0x78, 0x29, 0xb5, 0xd4, 0x72, 0xa7, 0x6f, 0xe8, 0x1d, 0xb9, 0x44, 0xa3, 0x33,
	0xf4, 0xa1, 0xa1, 0x9b, 0xf4, 0x1d, 0xf2, 0xe4, 0x36, 0xdc, 0x72, 0x82, 0xa9, 0xc6, 0xfe, 0x0f,
	0x6b, 0xce, 0x0b, 0x8d, 0xff, 0x69, 0xfe, 0x7e, 0x3e, 0xf9, 0x3b, 0x00, 0x00, 0xff, 0xff, 0x74,
	0x97, 0x44, 0x5c, 0x66, 0x0f, 0x00, 0x00,
}
